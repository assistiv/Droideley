package com.droideley.tools;

import java.io.File;
import java.util.LinkedList;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.app.Activity;
import android.content.Context;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Environment;

import com.droideley.comm.SQLiteHelper;
import com.droideley.data.MendeleyAuthor;
import com.droideley.data.MendeleyDocument;
import com.droideley.data.MendeleyFile;
import com.droideley.data.MendeleyGroup;

public class DroideleyTools {

	private static LinkedList<String> docs = new LinkedList<String>();
/*
	private static void findPdfs(List<String> pdfs) {
		boolean mExternalStorageAvailable = false;
		boolean mExternalStorageWriteable = false;
		String state = Environment.getExternalStorageState();

		if (Environment.MEDIA_MOUNTED.equals(state)) {
			mExternalStorageAvailable = mExternalStorageWriteable = true;
		} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
			mExternalStorageAvailable = true;
			mExternalStorageWriteable = false;
		} else {
			mExternalStorageAvailable = mExternalStorageWriteable = false;
		}

		if (mExternalStorageAvailable) {
			File root = Environment.getExternalStorageDirectory();
			listPdfs(root, pdfs);
		} else {
			return;
		}
	}

	private static void listPdfs(File path, List<String> pdfs) {
		System.out.println("Listing files ============");
		System.out.println("Dir:" + path.getAbsolutePath());
		if (path.exists()) {
			File[] files = path.listFiles();
			if (files != null) {
				for (int i = 0; i < files.length; i++) {
					if (files[i].isDirectory()) {
						listPdfs(files[i], pdfs);
					} else if (files[i].getName().endsWith("pdf")) {
						System.out.println("Huray!!! --- " + files[i].getName());
						pdfs.add(files[i].getAbsolutePath());
					}
				}
			}
		}
	}

	/**
	 * Finds all pdf files on the SD card and then tries to link that files with
	 * the mendeley documents stored in the local db. It pairs the mendeley
	 * document with the pdf only if the pdf filename contains full document's
	 * title string.
	 * 
	 * @param context
	 */
/*	
	public static void pairDocsWithPdfs(Context context) {

		// LinkedList<String> docs = new LinkedList<String>();
		LinkedList<String> pdfs = new LinkedList<String>();

		findPdfs(pdfs);
		SQLiteDatabase db = new SQLiteHelper(context).getWritableDatabase();
		Cursor dbDocs = db.rawQuery("SELECT doc_id, title, pdf FROM documents", null);
		System.out.println("Fetching docs from DB...");
		while (dbDocs.moveToNext()) {
			// System.out.println("Doc:" + dbDocs.getString(1));
			if (dbDocs.getString(2) != null) {
				if (new File(dbDocs.getString(2)).exists()) {
					System.out.println("File found for: " + dbDocs.getString(2));
				} else {
					System.out.println(dbDocs.getString(1).toLowerCase().replace(":", ""));
					for (String filename : pdfs) {
						if (filename.toLowerCase().contains(
								dbDocs.getString(1).toLowerCase().replace(":", ""))) {
							filename = filename.replaceAll("'", "''");
							db.execSQL("UPDATE documents SET pdf='" + filename + "' WHERE doc_id='"
									+ dbDocs.getLong(0) + "'");
						}
					}
				}
			} else {
				System.out.println(dbDocs.getString(1).toLowerCase().replace(":", ""));
				for (String filename : pdfs) {
					if (filename.toLowerCase().contains(
							dbDocs.getString(1).toLowerCase().replace(":", ""))) {
						filename = filename.replaceAll("'", "''");
						db.execSQL("UPDATE documents SET pdf='" + filename + "' WHERE doc_id='"
								+ dbDocs.getLong(0) + "'");
					}
				}
			}
		}
		dbDocs.close();
		db.close();
	}
*/

	/**
	 * Test the internet connection status
	 * @param context
	 * @return true if connected, false otherwise
	 */
	public static boolean checkConnection(Context context) {
		NetworkInfo ni = (NetworkInfo) ((ConnectivityManager) context
				.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();
		if (ni == null || !ni.isConnected()) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Creates MendeleyDocument object representing the information encapsulated
	 * in the given JSON object. It is expected that the JSON object was
	 * generated by the Mendeley API
	 * 
	 * @param docJSON JSON object to be parsed
	 * @return MendeleyDocument instance
	 */
	public static MendeleyDocument documentFromJSON(JSONObject docJSON) {
		MendeleyDocument res = new MendeleyDocument();
		try {
			if (docJSON.has("id")) {
				res.setId(docJSON.getLong("id"));
			}
			if (docJSON.has("canonical_id")) {
				res.setCanonicalId(docJSON.getString("canonical_id"));
			}
			if (docJSON.has("uuid")) {
				res.setUuid(docJSON.getString("uuid"));
			}
			if (docJSON.has("title")) {
				res.setTitle(docJSON.getString("title"));
			}
			if (docJSON.has("abstract")) {
				res.setDocAbstract(docJSON.getString("abstract"));
			}
			// Parsing authors
			if (docJSON.has("authors")) {
				JSONArray authorsJSON;
				// If the document is a result of a private "Documents details"
				// method
				if ((authorsJSON = docJSON.optJSONArray("authors")) != null) {
					LinkedList<MendeleyAuthor> authors = new LinkedList<MendeleyAuthor>();
					authorsJSON = docJSON.getJSONArray("authors");
					for (int i = 0; i < authorsJSON.length(); i++) {
						JSONObject author = authorsJSON.getJSONObject(i);
						authors.add(new MendeleyAuthor(author.getString("forename"), author
								.getString("surname")));
					}
					res.setAuthors(authors);
				} else {
					// Else if it is a call of "Documents search" method
					res.setAuthorsString(docJSON.getString("authors"));
				}
			}
			if (docJSON.has("year")) {
				res.setYear(docJSON.getInt("year"));
			}
			// Parsing identifiers
			if (docJSON.has("identifiers")) {
				// doi
				// isbn
			}
			// Parsing tags
			if (docJSON.has("tags")) {
				JSONArray tagsJSON = docJSON.getJSONArray("tags");
				LinkedList<String> tags = new LinkedList<String>();
				for (int i = 0; i < tagsJSON.length(); i++) {
					tags.add(tagsJSON.getString(i));
				}
				res.setTags(tags);
			}
			// Parsing outlet
			if (docJSON.has("publication_outlet")) {
				res.setOutlet(docJSON.getString("publication_outlet"));
			}
			// Parsing files
			if (docJSON.has("files")) {
				JSONArray filesJSON = docJSON.getJSONArray("files");
				LinkedList<MendeleyFile> files = new LinkedList<MendeleyFile>();
				for (int i = 0; i < filesJSON.length(); i++) {
					JSONObject fileJSON = filesJSON.getJSONObject(i);
					files.add(new MendeleyFile(fileJSON.has("file_hash") ? fileJSON
							.getString("file_hash") : null, fileJSON.has("date_added") ? fileJSON
							.getString("date_added") : null,
							fileJSON.has("file_extension") ? fileJSON.getString("file_extension")
									: null, res.getId(), fileJSON.has("file_size") ? fileJSON
									.getInt("file_size") : null));
				}
				res.setFiles(files);
			}
			if (docJSON.has("mendeley_url")) {
				res.setMendeleyUrl(docJSON.getString("mendeley_url"));
			}
			if (docJSON.has("url")) {
				res.setUrl(docJSON.getString("url"));
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return res;
	}

	/**
	 * Parses the group JSON object and returns MendeleyGroup instance
	 * 
	 * @param groupJSON
	 *            the JSON object to be parsed
	 * @return MendeleyGroup instance
	 */
	public static MendeleyGroup groupFromJSON(JSONObject groupJSON) {
		MendeleyGroup res = new MendeleyGroup();
		try {
			res.setGroupId(groupJSON.getInt("id"));
			res.setName(groupJSON.getString("name"));
			res.setSize(groupJSON.getInt("size"));
			res.setType(groupJSON.getString("type"));
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return res;
	}

	public static void lockScreenOrientation(Activity context, boolean val) {
		// Stop the screen orientation changing during an event
		if (val) {
			switch (context.getResources().getConfiguration().orientation) {
			case Configuration.ORIENTATION_PORTRAIT:
				context.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
				break;
			case Configuration.ORIENTATION_LANDSCAPE:
				context.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
				break;
			}
		} else {
			context.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
		}
	}
}
